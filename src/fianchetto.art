;===============================================
; Fianchetto
;
; Chess-aware components, custom types,
; FEN & PGN parsing & more...
; for Arturo
;
; MIT License
; (c) 2024 Yanis Zafirópulos
;==========================================================
; @file: src/fianchetto.art
;==========================================================

import 'tabular!

; Define chess coordinates type
define :chessCoords [
    init: method [
        coords :string :block  
    ][
        ensure.that:"Coordinates' size is valid" -> 2 = size coords
        
        \file: coords\0
        \rank: coords\1

        unless integer? \rank ->
            \rank: to :integer to :string \rank

        ensure.that:"Coordinate file is valid" -> in? \file 'a'..'h' 
        ensure.that:"Coordinate rank is valid" -> in? \rank 1..8
    ]

    string: method [][
        join @[\file to :string \rank]
    ]

    index: method [][
        fileIndex: (to :integer \file) - to :integer 'a'
        rankIndex: dec \rank
        fileIndex + rankIndex * 8
    ]
]

; Define chess piece type
define :chessPiece [
    init: method [
        ch :char :literal :string
    ][
        pc: to :string (string? ch)? -> first ch -> ch

        \color: switch upper? pc -> 'white -> 'black
        \kind: to :literal lower pc
        
        ensure.that:"Piece is valid" -> in? \kind ['p 'n 'b 'r 'q 'k]
    ]

    white?: method [][
        \color = 'white
    ]

    string: method [][
        pieceChar: to :string \kind
        if \white? [ 
            pieceChar: upper pieceChar 
        ]
        pieceChar
    ]
]

; Define chess move type
define :chessMove [
    init: method [
        coordset :string :block 
    ][
        switch string? coordset [
            cleaned: replace coordset "-" ""

            ensure.that:"Move format is valid" -> 4 = size cleaned

            \fromSq: to :chessCoords [slice cleaned 0 1]
            \toSq: to :chessCoords [slice cleaned 2 3]
        ][
            ensure.that:"Move format is valid" -> 2 = size coordset

            \fromSq: coordset\0
            \toSq: coordset\1
        ]
    ]

    string: method [][
        join @[
            to :string \fromSq
            to :string \toSq
        ]
    ]
]

; Define chess board type
define :chessBoard [
    init: method [][
        ; Initialize a 64-element array for the board
        ; squares[0] = a1, squares[1] = b1, ..., squares[63] = h8
        \squares: array.of:64 ø       ; create array with 64 null elements
    ]

    ; Get piece at coordinates
    getPiece: method [coords :chessCoords][
        \squares\[coords\index]
    ]

    ; Set piece at coordinates (null to clear)
    setPiece: method [coords :chessCoords piece :null :chessPiece][
        \squares\[coords\index]: piece
    ]

    ; Convert board to FEN notation 
    notation: method [][
        result: ""
        loop 7..0 'rank [
            emptyCount: 0
            loop 0..7 'file [
                coords: to :chessCoords [@[to :char (to :integer 'a') + file, 8 - rank]]!
                piece: \getPiece coords
                
                switch null? piece -> inc 'emptyCount [
                    if emptyCount > 0 [
                        result: result ++ to :string emptyCount
                        emptyCount: 0
                    ]
                    result: result ++ to :string piece
                ]
            ]
            
            if emptyCount > 0 [
                result: result ++ to :string emptyCount
            ]

            if rank > 0 -> result: result ++ "/"
        ]
        result
    ]

    string: method [][
        rows: map 8..1 'rank [
            map 'a'..'h' 'file [
                coords: to :chessCoords [@[file rank]]!
                piece: \getPiece coords

                (null? piece)? -> "-" 
                               -> to :string piece
            ]
        ]
        tabular.align:'center .padding:0 rows
    ]
]

; Define chess position type
define :chessPosition [
    init: method [source :string :null][
        fenSrc: source ?? "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
        parts: split.by:" " read fenSrc
        ensure.that:"Invalid FEN string format" -> 6 = size parts

        \board: to :chessBoard []!
        ranks: split.by:"/" parts\0
        ensure.that:"Invalid number of ranks in FEN" -> 8 = size ranks

        ; Parse board position from top (rank 8) to bottom (rank 1)
        loop.with:'rankIndex ranks 'rank [
            fileIndex: 0
            loop split rank 'ch [
                switch numeric? ch -> fileIndex: fileIndex + to :integer ch [
                    coords: to :chessCoords [@[
                        to :char (to :integer 'a') + fileIndex,  ; file (a-h)
                        8 - rankIndex                            ; rank (8 down to 1)
                    ]]!
                    piece: to :chessPiece [ch]!
                    \board\setPiece coords piece
                    inc 'fileIndex
                ]
            ]
        ]

        \activeColor: switch parts\1 = "w" -> 'white -> 'black  ; active color
        \castling: parts\2                                      ; castling
        \enPassant: parts\3                                     ; en passant
        \halfmove: to :integer parts\4                          ; halfmove clock
        \fullmove: to :integer parts\5                          ; fullmove number
    ]

    ; Validate if a move is legal in current position
    validateMove: method [move :chessMove][
        
        ; 1. Basic piece existence and color check
        piece: \board\getPiece move\fromSq
        
        if null? piece [
            print "No piece at source square"
            return false
        ]
        
        if piece\color <> \activeColor [
            print "Wrong color to move"
            return false
        ]

        ; 2. Check if piece at destination is not same color
        destPiece: \board\getPiece move\toSq
        
        unless null? destPiece [
            if destPiece\color = piece\color [
                print "Cannot capture own piece"
                return false
            ]
        ]

        return true
    ]

    copy: method [][
        newPos: to :chessPosition [ø]!
        
        ; Copy basic properties
        newPos\activeColor: \activeColor
        newPos\castling: \castling
        newPos\enPassant: \enPassant 
        newPos\halfmove: \halfmove
        newPos\fullmove: \fullmove

        ; Deep copy of board
        newPos\board: to :chessBoard []!
        loop 0..63 'i [
            piece: \board\squares\[i]
            if piece [
                newPos\board\squares\[i]: to :chessPiece [to :string piece]!
            ]
        ]

        return newPos
    ]

    ; Create a new position after applying the move
    applyMove: method [move :chessMove][
        ; Create new position with same properties
        newPos: \copy
            
        ; Get and copy the piece we're moving
        piece: \board\getPiece move\fromSq
        piece: to :chessPiece [to :string piece]! ; Create new copy of piece
            
        ; Clear source square and set destination square
        newPos\board\setPiece move\fromSq null
        newPos\board\setPiece move\toSq piece 

        ; Update position details
        newPos\activeColor: switch \activeColor = 'white -> 'black -> 'white
        newPos\fullmove: switch \activeColor = 'black -> \fullmove + 1 -> \fullmove

        return newPos
    ]
    ; Convert position to FEN string
    string: method [][
        colorNotation: switch \activeColor = 'white -> "w" -> "b"

        join.with:" " @[
            \board\notation
            colorNotation
            \castling
            \enPassant
            to :string \halfmove
            to :string \fullmove
        ]
    ]
]

; Define chess game result type
define :chessGameResult [
    init: method [
        value :string :literal :null
    ][
        \winner: value

        if null? \winner ->
            \winner: 'none

        if string? \winner [
            \winner: case \winner [
                "1-0"     -> 'white
                "0-1"     -> 'black
                "1/2-1/2" -> 'draw
                "*"       -> 'none
            ]
        ]

        ensure.that:"Game result type is valid" -> 
            in? \winner ['white 'black 'draw 'none]
    ]

    string: method [][
        case \winner [
            'white -> "1-0"
            'black -> "0-1"
            'draw  -> "1/2-1/2"
            'none  -> "*"
        ]
    ]

    final?: method [][
        \winner <> 'none
    ]
]

; Define chess game metadata type
define :chessGameMetadata [
    init: method [source :dictionary :null][
        ; Initialize with default values
        \event: "Casual Game"
        \site: "?"
        \date: slice to :string now 0 10  ; YYYY-MM-DD
        \round: "?"
        \white: "Player 1"
        \black: "Player 2"
        \timeControl: "?"
        \eco: "?"

        ; If source dictionary provided, update values
        if dictionary? source [
            loop source [k,v][
                if key? this k [
                    this\[k]: v
                ]
            ]
        ]
    ]

    string: method [][
        join @[
            "[Event \""    \event       "\"]\n"
            "[Site \""     \site        "\"]\n"
            "[Date \""     \date        "\"]\n"
            "[Round \""    \round       "\"]\n"
            "[White \""    \white       "\"]\n"
            "[Black \""    \black       "\"]\n"
            "[Result \""   \timeControl "\"]\n"
            "[ECO \""      \eco         "\"]"
        ]
    ]
]

; Update chess game type to use new metadata type
define :chessGame [
    init: method [
        source :string :null    ; could be PGN or null for new game
    ][
        \position: to :chessPosition [ø]!   
        \moves: []
        \result: to :chessGameResult [ø]!   
        \metadata: to :chessGameMetadata [ø]!

        if not? null? source [
            if contains? source "[" [  
                ; Split into header and moves sections
                parts: split.by:"\n\n" source

                ; Parse headers
                headers: #[]
                if contains? parts\0 "[" [
                    matches: match.capture parts\0 {/\[(.*?) "(.*?)"\]/} 
                    loop matches 'm [
                        tag: lower m\0
                        value: m\1
                        headers\[tag]: value
                    ]

                    \metadata: to :chessGameMetadata [headers]!
                    if key? headers 'result [
                        \result: to :chessGameResult [headers\result]!
                    ]
                ]

                ; Parse moves if we have more than one part
                if 1 < size parts [
                    movesText: join drop parts
                    
                    ; Remove comments
                    cleaned: replace movesText to :regex {:\{[^}]*\}:} ""
                    
                    ; Remove move numbers and result
                    cleaned: replace cleaned {/\d+\.+\s*/} ""      
                    cleaned: replace cleaned {/1-0|0-1|1\/2-1\/2|\*/} "" 
                    
                    ; Split into individual moves and process each
                    moves: split.words cleaned
                    
                    loop moves 'moveStr [
                        if not? contains? moveStr "-" [
                            \makeMove moveStr
                        ]
                    ]
                ]
            ]
        ]
    ]

    makeMove: method [coords :chessMove :string][
        move: (is? :chessMove coords)? -> coords -> to :chessMove [coords]
        
        unless \position\validateMove move ->
            return false
    
        \position: \position\applyMove move
        \moves: \moves ++ move
        return true
    ]

    string: method [][
        output: to :string \metadata
        output: output ++ "\n\n"

        ; Add moves
        moveNum: 1
        loop \moves 'move [
            if even? index -> output: output ++ (to :string moveNum) ++ ". "
            output: output ++ (to :string move) ++ " "
            if even? index -> inc 'moveNum
        ]

        ; Add result
        output: output ++ " " ++ to :string \result
        output
    ]
]